## 基于贫血模型的传统开发模式

实际上，如果你有一定 Web 项目的开发经验，并且听明白了我刚刚讲的设计思路，那对你来说，利用基于贫血模型的传统开发模式来实现这样一个系统，应该是一件挺简单的事情。不过，为了对比两种开发模式，我还是带你一块儿来实现一遍。

这是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，我省略了具体的代码实现。

```
public class VirtualWalletController {

  // 通过构造函数或者 IOC 框架注入

  private VirtualWalletService virtualWalletService;



  public BigDecimal getBalance(Long walletId) { ... } // 查询余额

  public void debit(Long walletId, BigDecimal amount) { ... } // 出账

  public void credit(Long walletId, BigDecimal amount) { ... } // 入账

  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} // 转账

}
```

Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service 层的代码如下所示。注意，这里我省略了一些不重要的校验代码，比如，对 amount 是否小于 0、钱包是否存在的校验等等。

```
public class VirtualWalletBo {// 省略 getter/setter/constructor 方法

  private Long id;

  private Long createTime;

  private BigDecimal balance;

}

public class VirtualWalletService {

  // 通过构造函数或者 IOC 框架注入

  private VirtualWalletRepository walletRepo;

  private VirtualWalletTransactionRepository transactionRepo;



  public VirtualWalletBo getVirtualWallet(Long walletId) {

​    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);

​    VirtualWalletBo walletBo = convert(walletEntity);

​    return walletBo;

  }



  public BigDecimal getBalance(Long walletId) {

​    return virtualWalletRepo.getBalance(walletId);

  }



  public void debit(Long walletId, BigDecimal amount) {

​    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);

​    BigDecimal balance = walletEntity.getBalance();

​    if (balance.compareTo(amount) < 0) {

​      throw new NoSufficientBalanceException(...);

​    }

​    walletRepo.updateBalance(walletId, balance.subtract(amount));

  }



  public void credit(Long walletId, BigDecimal amount) {

​    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);

​    BigDecimal balance = walletEntity.getBalance();

​    walletRepo.updateBalance(walletId, balance.add(amount));

  }



  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {

​    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();

​    transactionEntity.setAmount(amount);

​    transactionEntity.setCreateTime(System.currentTimeMillis());

​    transactionEntity.setFromWalletId(fromWalletId);

​    transactionEntity.setToWalletId(toWalletId);

​    transactionEntity.setStatus(Status.TO_BE_EXECUTED);

​    Long transactionId = transactionRepo.saveTransaction(transactionEntity);

​    try {

​      debit(fromWalletId, amount);

​      credit(toWalletId, amount);

​    } catch (InsufficientBalanceException e) {

​      transactionRepo.updateStatus(transactionId, Status.CLOSED);

​      ...rethrow exception e...

​    } catch (Exception e) {

​      transactionRepo.updateStatus(transactionId, Status.FAILED);

​      ...rethrow exception e...

​    }

    transactionRepo.updateStatus(transactionId, Status.EXECUTED);

  }

}
```

以上便是利用基于贫血模型的传统开发模式来实现的虚拟钱包系统。尽管我们对代码稍微做了简化，但整体的业务逻辑就是上面这样子。其中大部分代码逻辑都非常简单，最复杂的是 Service 中的 transfer () 转账函数。我们为了保证转账操作的数据一致性，添加了一些跟 transaction 相关的记录和状态更新的代码，理解起来稍微有点难度，你可以对照着之前讲的设计思路，自己多思考一下。

## 基于充血模型的 DDD 开发模式

刚刚讲了如何利用基于贫血模型的传统开发模式来实现虚拟钱包系统，现在，我们再来看一下，如何利用基于充血模型的 DDD 开发模式来实现这个系统？

在上一节课中，我们讲到，基于充血模型的 DDD 开发模式，跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，我们重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现。

在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。具体的代码实现如下所示：

```
public class VirtualWallet { // Domain 领域模型 (充血模型)

  private Long id;

  private Long createTime = System.currentTimeMillis();;

  private BigDecimal balance = BigDecimal.ZERO;



  public VirtualWallet(Long preAllocatedId) {

​    this.id = preAllocatedId;

  }



  public BigDecimal balance() {

​    return this.balance;

  }



  public void debit(BigDecimal amount) {

​    if (this.balance.compareTo(amount) < 0) {

​      throw new InsufficientBalanceException(...);

​    }

​    this.balance.subtract(amount);

  }



  public void credit(BigDecimal amount) {

​    if (amount.compareTo(BigDecimal.ZERO) < 0) {

​      throw new InvalidAmountException(...);

​    }

​    this.balance.add(amount);

  }

}

public class VirtualWalletService {

  // 通过构造函数或者 IOC 框架注入

  private VirtualWalletRepository walletRepo;

  private VirtualWalletTransactionRepository transactionRepo;



  public VirtualWallet getVirtualWallet(Long walletId) {

​    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);

​    VirtualWallet wallet = convert(walletEntity);

​    return wallet;

  }



  public BigDecimal getBalance(Long walletId) {

​    return virtualWalletRepo.getBalance(walletId);

  }



  public void debit(Long walletId, BigDecimal amount) {

​    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);

​    VirtualWallet wallet = convert(walletEntity);

​    wallet.debit(amount);

​    walletRepo.updateBalance(walletId, wallet.balance());

  }



  public void credit(Long walletId, BigDecimal amount) {

​    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);

​    VirtualWallet wallet = convert(walletEntity);

​    wallet.credit(amount);

​    walletRepo.updateBalance(walletId, wallet.balance());

  }



  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {

​    //... 跟基于贫血模型的传统开发模式的代码一样...

  }

}
```

看了上面的代码，你可能会说，领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下 VirtualWallet 类的实现代码。

```
public class VirtualWallet {

  private Long id;

  private Long createTime = System.currentTimeMillis();;

  private BigDecimal balance = BigDecimal.ZERO;

  private boolean isAllowedOverdraft = true;

  private BigDecimal overdraftAmount = BigDecimal.ZERO;

  private BigDecimal frozenAmount = BigDecimal.ZERO;



  public VirtualWallet(Long preAllocatedId) {

​    this.id = preAllocatedId;

  }



  public void freeze(BigDecimal amount) { ... }

  public void unfreeze(BigDecimal amount) { ...}

  public void increaseOverdraftAmount(BigDecimal amount) { ... }

  public void decreaseOverdraftAmount(BigDecimal amount) { ... }

  public void closeOverdraft() { ... }

  public void openOverdraft() { ... }



  public BigDecimal balance() {

​    return this.balance;

  }



  public BigDecimal getAvaliableBalance() {

​    BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);

​    if (isAllowedOverdraft) {

​      totalAvaliableBalance += this.overdraftAmount;

​    }

​    return totalAvaliableBalance;

  }



  public void debit(BigDecimal amount) {

​    BigDecimal totalAvaliableBalance = getAvaliableBalance();

​    if (totoalAvaliableBalance.compareTo(amount) < 0) {

​      throw new InsufficientBalanceException(...);

​    }

​    this.balance.subtract(amount);

  }



  public void credit(BigDecimal amount) {

​    if (amount.compareTo(BigDecimal.ZERO) < 0) {

​      throw new InvalidAmountException(...);

​    }

​    this.balance.add(amount);

  }

}
```

领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入 ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。

## 辩证思考与灵活应用

对于虚拟钱包系统的设计与两种开发模式的代码实现，我想你应该有个比较清晰的了解了。不过，我觉得还有两个问题值得讨论一下。

**第一个要讨论的问题是：在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在我们的代码设计与实现中，并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？**

区别于 Domain 的职责，Service 类主要有下面这样几个职责。

1. Service 类负责与 Repository 交流。在我的设计与代码实现中，VirtualWalletService 类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。

这里我再稍微解释一下，之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。

2. Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer () 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。

3. Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。

**第二个要讨论问题是：在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？**

答案是没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。

尽管这样的设计是一种面向过程的编程风格，但我们只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？

就拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面相对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。

我们再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。

## 重点回顾

今天的内容到此就讲完了。我们一块来总结回顾一下，你应该重点掌握的知识点。

基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。

在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。

基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。

## 课堂讨论

这两节课中对于 DDD 的讲解，都是我的个人主观看法，你可能会有不同看法。

欢迎在留言区说一说你对 DDD 的看法。如果觉得有帮助，你也可以把这篇文章分享给你的朋友。
