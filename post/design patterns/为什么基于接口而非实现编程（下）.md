## 前言

那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从 “基于接口而非实现编程” 的原则，具体来讲，我们需要做到下面这 3 点。

1. 函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun () 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload ()。

2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。

3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。

我们按照这个思路，把代码重构一下。重构后的代码如下所示：

```
public interface ImageStore {

  String upload(Image image, String bucketName);

  Image download(String url);

}

public class AliyunImageStore implements ImageStore {

  //... 省略属性、构造函数等...

  public String upload(Image image, String bucketName) {

    createBucketIfNotExisting(bucketName);

    String accessToken = generateAccessToken();

    //... 上传图片到阿里云...

    //... 返回图片在阿里云上的地址 (url)...

  }

  public Image download(String url) {

    String accessToken = generateAccessToken();

    //... 从阿里云下载图片...

  }

  private void createBucketIfNotExisting(String bucketName) {

    //... 创建 bucket...

    //... 失败会抛出异常..

  }

  private String generateAccessToken() {

    //... 根据 accesskey/secrectkey 等生成 access token

  }

}

// 上传下载流程改变：私有云不需要支持 access token

public class PrivateImageStore implements ImageStore  {

  public String upload(Image image, String bucketName) {

    createBucketIfNotExisting(bucketName);

    //... 上传图片到私有云...

    //... 返回图片的 url...

  }

  public Image download(String url) {

    //... 从私有云下载图片...

  }

  private void createBucketIfNotExisting(String bucketName) {

    //... 创建 bucket...

    //... 失败会抛出异常..

  }

}

// ImageStore 的使用举例

public class ImageProcessingJob {

  private static final String BUCKET_NAME = "ai_images_bucket";

  //... 省略其他无关代码...


  public void process() {

    Image image = ...;// 处理图片，并封装为 Image 对象

    ImageStore imageStore = new PrivateImageStore(...);

    imagestore.upload(image, BUCKET_NAME);

  }

}
```

除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken () 方法。

总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

## 是否需要为每个类定义接口？

看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？

做任何事情都要讲求一个 “度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。

前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。

从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。

## 重点回顾

今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。

1.“基于接口而非实现编程”，这条原则的另一个表述方式，是 “基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。

2. 我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

3.“基于接口而非实现编程” 这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的 “接口” 设计、类库的 “接口” 设计。

## 课堂讨论

在今天举的代码例子中，尽管我们通过接口来隔离了两个具体的实现。但是，在项目中很多地方，我们都是通过下面第 8 行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。这样的设计还是不够完美，对此，你有更好的实现思路吗？

```
// ImageStore 的使用举例

public class ImageProcessingJob {

  private static final String BUCKET_NAME = "ai_images_bucket";

  //... 省略其他无关代码...


  public void process() {

    Image image = ...;// 处理图片，并封装为 Image 对象

    ImageStore imageStore = new PrivateImageStore(/* 省略构造函数 */);

    imagestore.upload(image, BUCKET_NAME);

  }
```
