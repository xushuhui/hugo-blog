---
title: Error Type
date: 2016-07-01 13:59:58
tags: ["HTTP","网络协议","编程基础"]
categories: ["HTTP"]
---

## Sentinel Error

预定义的特定错误，我们叫为 *sentinel error*，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。

 `if err == ErrSomething{ … }`

类似的 *io.EOF*，更底层的 *syscall.ENOENT*。

*使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。*
*甚至是一些有意义的 fmt. Errorf 携带一些上下文，也会破坏调用者的 ==，调用者将被迫查看 error. Error() 方法的输出，以查看它是否与特定的字符串匹配。*

不依赖检查 *error.Error* 的输出。

*不应该依赖检测 error. Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序编写测试可能会依赖这个返回。这个输出的字符串用于记录日志、输出到 stdout 等。*

### Sentinel errors 成为你 API 公共部分。

如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。
如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。
比如 io. Reader。像 io. Copy 这类函数需要 reader 的实现者比如返回 io. EOF 来告诉调用者没有更多数据了，但这又不是错误。

### Sentinel errors 在两个包之间创建了依赖。

sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io. EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件。

### 结论：尽可能避免 sentinel errors。

我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。

## Error Type

Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。
