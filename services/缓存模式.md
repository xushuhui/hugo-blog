
### 缓存模式 - 数据一致性
Storage 和 Cache 同步更新容易出现数据不一致。
模拟 MySQL Slave 做数据复制，再把消息投递到 Kafka，保证至少一次消费：
- 同步操作DB；
- 同步操作Cache；
- 利用Job消费消息，重新补偿一次缓存操作
保证时效性和一致性。
![image](https://tva3.sinaimg.cn/large/a616b9a4gy1gmrsl5mfirj20xx0towrc.jpg)

Cache Aside 模型中，读缓存 Miss 的回填操作，和修改数据同步更新缓存，包括消息队列的异步补偿缓存，都无法满足 “Happens Before”，会存在相互覆盖的情况。

![image](https://tva1.sinaimg.cn/large/a616b9a4gy1gmrsmxdfczj21q40j2tce.jpg)

读/写同时操作：
- 读操作，读缓存，缓存 MISS
- 读操作，读 DB，读取到数据
- 写操作，更新 DB 数据
- 写操作 SET/DELETE Cache（可 Job 异步操作）
- 读操作，SET操作数据回写缓存（可 Job 异步操作）
**这种交互下，由于4和5操作步骤都是设置缓存，导致写入的值互相覆盖；并且操作的顺序性不确定，从而导致 cache 存在脏缓存的情况。**

读/写同时操作：
- 读操作，读缓存，缓存 MISS
- 读操作，读 DB，读取到数据
- 写操作，更新 DB 数据
- 写操作 SET Cache（可异步 job 操作，Redis 可以使用 SETEX 操作）
- 读操作，ADD 操作数据回写缓存（可 Job异步操作，Redis 可以使用 SETNX 操作）
**写操作使用 SET 操作命令，覆盖写缓存；读操作，使用 ADD 操作回写 MISS 数据，从而保证写操作的最新数据不会被读操作的回写数据覆盖。**

